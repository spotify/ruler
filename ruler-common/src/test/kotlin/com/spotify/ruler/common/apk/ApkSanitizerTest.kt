/*
* Copyright 2021 Spotify AB
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.spotify.ruler.common.apk

import com.google.common.truth.Truth.assertThat
import com.spotify.ruler.common.sanitizer.ClassNameSanitizer
import com.spotify.ruler.common.sanitizer.ResourceNameSanitizer
import com.spotify.ruler.models.AppFile
import com.spotify.ruler.models.FileType
import com.spotify.ruler.models.ResourceType
import org.junit.jupiter.api.Test

class ApkSanitizerTest {
    private val sanitizer = ApkSanitizer(ClassNameSanitizer(null), ResourceNameSanitizer(null))

    @Test
    fun `Class files are unpacked from DEX entries`() {
        val dirty = ApkEntry.Dex("classes.dex", 1000, 2000, classes = listOf(
            ApkEntry.Default("Lcom/spotify/MainActivity;", 1000, 1000),
            ApkEntry.Default("Lcom/spotify/LoginActivity;", 1000, 1000),
        ))
        val clean = sanitizer.sanitize(listOf(dirty))

        assertThat(clean).containsExactly(
            AppFile("com.spotify.MainActivity", FileType.CLASS, 500, 1000),
            AppFile("com.spotify.LoginActivity", FileType.CLASS, 500, 1000),
        )
    }

    @Test
    fun `Android manifests from secondary APKs are removed`() {
        val dirty = listOf(
            ApkEntry.Default("/AndroidManifest.xml", 100, 200),
            ApkEntry.Default("/AndroidManifest.xml", 400, 600),
            ApkEntry.Default("/AndroidManifest.xml", 50, 100),
        )
        val clean = sanitizer.sanitize(dirty)

        assertThat(clean).containsExactly(AppFile("/AndroidManifest.xml", FileType.OTHER, 400, 600))
    }

    @Test
    fun `Compiled resources are merged`() {
        val dirty = listOf(
            ApkEntry.Default("/resources.arsc", 100, 200),
            ApkEntry.Default("/resources.arsc", 100, 200),
            ApkEntry.Default("/resources.arsc", 100, 200),
        )
        val clean = sanitizer.sanitize(dirty)

        assertThat(clean).containsExactly(AppFile("/resources.arsc", FileType.OTHER, 300, 600))
    }

    @Test
    fun `Files generated by Bundletool are removed`() {
        val dirty = listOf(
            ApkEntry.Default("/META-INF/MANIFEST.MF", 0, 0),
            ApkEntry.Default("/res/xml/splits0.xml", 0, 0),
            ApkEntry.Default("/res/xml/splits17.xml", 0, 0),
        )
        val clean = sanitizer.sanitize(dirty)

        assertThat(clean).isEmpty()
    }

    @Test
    fun `Layout resources are assigned the correct type`() {
        val dirty = ApkEntry.Default("/res/layout/activity_main.xml", 0, 0)
        val clean = sanitizer.sanitize(listOf(dirty)).single()

        assertThat(clean.type).isEqualTo(FileType.RESOURCE)
        assertThat(clean.resourceType).isEqualTo(ResourceType.LAYOUT)
    }

    @Test
    fun `Drawable resources are assigned the correct type`() {
        val dirty = ApkEntry.Default("/res/drawable/test_drawable.xml", 0, 0)
        val clean = sanitizer.sanitize(listOf(dirty)).single()

        assertThat(clean.type).isEqualTo(FileType.RESOURCE)
        assertThat(clean.resourceType).isEqualTo(ResourceType.DRAWABLE)
    }

    @Test
    fun `Other resources are assigned the correct type`() {
        val dirty = ApkEntry.Default("/res/mipmap-hdpi/ic_launcher.png", 0, 0)
        val clean = sanitizer.sanitize(listOf(dirty)).single()

        assertThat(clean.type).isEqualTo(FileType.RESOURCE)
        assertThat(clean.resourceType).isEqualTo(ResourceType.OTHER)
    }

    @Test
    fun `Assets are assigned the correct type`() {
        val dirty = ApkEntry.Default("/assets/licenses.html", 0, 0)
        val clean = sanitizer.sanitize(listOf(dirty)).single()

        assertThat(clean.type).isEqualTo(FileType.ASSET)
    }

    @Test
    fun `Native libs are assigned the correct type`() {
        val dirty = ApkEntry.Default("/lib/arm64-v8a/lib.so", 0, 0)
        val clean = sanitizer.sanitize(listOf(dirty)).single()

        assertThat(clean.type).isEqualTo(FileType.NATIVE_LIB)
    }

    @Test
    fun `Native files are assigned the correct type`() {
        val dirty = ApkEntry.NativeLibrary("native-library.so", 1500, 3000, classes = listOf(
            ApkEntry.Default("[section .rela.dyn]", 1000, 1000),
            ApkEntry.Default("/buildbot/src/android/ndk-release-r21/external/libcxx/src/locale.cpp", 1000, 1000),
            ApkEntry.Default("/external/libcxxabi/src/cxa_demangle.cpp", 1000, 1000),
        ))
        val clean = sanitizer.sanitize(listOf(dirty))

        assertThat(clean).containsExactly(
            AppFile("native-library.so/[section .rela.dyn]",
                FileType.NATIVE_FILE, 500, 1000),
            AppFile("/buildbot/src/android/ndk-release-r21/external/libcxx/src/locale.cpp",
                FileType.NATIVE_FILE, 500, 1000),
            AppFile("/external/libcxxabi/src/cxa_demangle.cpp", FileType.NATIVE_FILE, 500, 1000),
        )
    }

    @Test
    fun `Other files are assigned the correct type`() {
        val dirty = ApkEntry.Default("/META-INF/kotlin-stdlib-common.kotlin_module", 0, 0)
        val clean = sanitizer.sanitize(listOf(dirty)).single()

        assertThat(clean.type).isEqualTo(FileType.OTHER)
    }
}
